name: Secure Deployment Pipeline

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  GO_VERSION: "1.21"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.inputs.environment || 'auto' }}
  cancel-in-progress: false  # Don't cancel production deployments

jobs:
  # Security and validation first
  security-validation:
    name: Security Validation
    runs-on: ubuntu-latest
    outputs:
      continue-deployment: ${{ steps.security-check.outputs.continue }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Security scan with gosec
        run: |
          go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
          gosec -fmt json -out gosec-report.json -stdout -severity medium ./...

      - name: Vulnerability check
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./...

      - name: Validate secrets availability
        id: security-check
        run: |
          # Check if required secrets are available (without exposing values)
          if [[ -z "${{ secrets.DOCKER_REGISTRY_TOKEN }}" ]]; then
            echo "Missing DOCKER_REGISTRY_TOKEN secret"
            exit 1
          fi
          if [[ -z "${{ secrets.DATABASE_URL }}" ]]; then
            echo "Missing DATABASE_URL secret"
            exit 1
          fi
          echo "continue=true" >> $GITHUB_OUTPUT

  # Build and test with secrets
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: security-validation
    if: needs.security-validation.outputs.continue-deployment == 'true'
    strategy:
      matrix:
        service:
          - api-gateway
          - auth-service
          - user-service
          - permission-service
          - notification-service
          - file-service
          - file-processing-service
          - webhook-service
          - mobile-bff
          - web-bff
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Check if service exists
        id: check-service
        run: |
          if [ -d "${{ matrix.service }}" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Run tests with secrets
        if: steps.check-service.outputs.exists == 'true'
        env:
          # Test environment secrets
          DATABASE_URL: postgresql://postgres:test_password@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379
          JWT_SECRET: ${{ secrets.TEST_JWT_SECRET }}
          API_KEY: ${{ secrets.TEST_API_KEY }}
          AIRTABLE_API_KEY: ${{ secrets.AIRTABLE_API_KEY }}
          AIRTABLE_BASE_ID: ${{ secrets.AIRTABLE_BASE_ID }}
          ENVIRONMENT: test
        run: |
          cd ${{ matrix.service }}
          go test -v -race -coverprofile=coverage.out ./...

      - name: Upload coverage
        if: steps.check-service.outputs.exists == 'true'
        uses: codecov/codecov-action@v3
        with:
          file: ${{ matrix.service }}/coverage.out
          flags: ${{ matrix.service }}

  # Build Docker images with secrets
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [security-validation, build-and-test]
    if: needs.security-validation.outputs.continue-deployment == 'true'
    strategy:
      matrix:
        service:
          - api-gateway
          - auth-service
          - user-service
          - permission-service
          - notification-service
          - file-service
          - file-processing-service
          - webhook-service
          - mobile-bff
          - web-bff
    steps:
      - uses: actions/checkout@v4

      - name: Check if service exists
        id: check-service
        run: |
          if [ -d "${{ matrix.service }}" ] && [ -f "${{ matrix.service }}/Dockerfile" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        if: steps.check-service.outputs.exists == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: steps.check-service.outputs.exists == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.DOCKER_REGISTRY_TOKEN }}

      - name: Extract metadata
        if: steps.check-service.outputs.exists == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,format=long

      - name: Build and push Docker image
        if: steps.check-service.outputs.exists == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Pass build-time secrets securely
          secrets: |
            "api_key=${{ secrets.BUILD_API_KEY }}"
            "registry_token=${{ secrets.DOCKER_REGISTRY_TOKEN }}"
          build-args: |
            GO_VERSION=${{ env.GO_VERSION }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
            REVISION=${{ github.sha }}

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-images]
    if: |
      (github.ref == 'refs/heads/main' || 
       github.event.inputs.environment == 'staging') &&
      needs.build-images.result == 'success'
    environment:
      name: staging
      url: https://staging.pyairtable.dev
    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure staging cluster access
        run: |
          echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Deploy to staging with secrets
        env:
          # Staging environment secrets
          DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
          REDIS_URL: ${{ secrets.STAGING_REDIS_URL }}
          JWT_SECRET: ${{ secrets.STAGING_JWT_SECRET }}
          API_KEY: ${{ secrets.STAGING_API_KEY }}
          AIRTABLE_API_KEY: ${{ secrets.AIRTABLE_API_KEY }}
          AIRTABLE_BASE_ID: ${{ secrets.STAGING_AIRTABLE_BASE_ID }}
          SENTRY_DSN: ${{ secrets.STAGING_SENTRY_DSN }}
        run: |
          # Update deployment with new image tags and inject secrets
          for service in api-gateway auth-service user-service permission-service notification-service file-service file-processing-service webhook-service mobile-bff web-bff; do
            if [ -d "$service" ] && [ -f "$service/Dockerfile" ]; then
              echo "Deploying $service to staging..."
              
              # Create secret for service if it doesn't exist
              kubectl create secret generic ${service}-secrets \
                --from-literal=database-url="$DATABASE_URL" \
                --from-literal=redis-url="$REDIS_URL" \
                --from-literal=jwt-secret="$JWT_SECRET" \
                --from-literal=api-key="$API_KEY" \
                --from-literal=airtable-api-key="$AIRTABLE_API_KEY" \
                --from-literal=airtable-base-id="$AIRTABLE_BASE_ID" \
                --from-literal=sentry-dsn="$SENTRY_DSN" \
                --dry-run=client -o yaml | kubectl apply -f -
              
              # Update deployment
              kubectl set image deployment/${service} ${service}=${{ env.REGISTRY }}/${{ github.repository_owner }}/${service}:${{ github.sha }} || echo "Deployment ${service} not found, skipping..."
              kubectl annotate deployment/${service} deployment.kubernetes.io/revision- || true
            fi
          done

      - name: Wait for staging deployment
        run: |
          for service in api-gateway auth-service user-service permission-service notification-service file-service file-processing-service webhook-service mobile-bff web-bff; do
            if kubectl get deployment ${service} >/dev/null 2>&1; then
              kubectl rollout status deployment/${service} --timeout=300s || echo "Deployment ${service} rollout timeout"
            fi
          done

      - name: Run staging health checks
        run: |
          # Wait for services to be ready
          sleep 30
          
          # Basic health check (customize based on your health endpoints)
          if ! curl -f -m 10 https://staging.pyairtable.dev/health; then
            echo "Staging health check failed"
            exit 1
          fi

  # Deploy to production (only on tags or manual trigger)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-images, deploy-staging]
    if: |
      (startsWith(github.ref, 'refs/tags/v') || 
       github.event.inputs.environment == 'production') &&
      needs.build-images.result == 'success' &&
      needs.deploy-staging.result == 'success'
    environment:
      name: production
      url: https://api.pyairtable.dev
    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure production cluster access
        run: |
          echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Pre-deployment backup
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        run: |
          # Create database backup before deployment
          echo "Creating pre-deployment backup..."
          # Add your backup script here
          
      - name: Deploy to production with secrets
        env:
          # Production environment secrets
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
          REDIS_URL: ${{ secrets.PRODUCTION_REDIS_URL }}
          JWT_SECRET: ${{ secrets.PRODUCTION_JWT_SECRET }}
          API_KEY: ${{ secrets.PRODUCTION_API_KEY }}
          AIRTABLE_API_KEY: ${{ secrets.AIRTABLE_API_KEY }}
          AIRTABLE_BASE_ID: ${{ secrets.PRODUCTION_AIRTABLE_BASE_ID }}
          SENTRY_DSN: ${{ secrets.PRODUCTION_SENTRY_DSN }}
        run: |
          # Blue-green deployment strategy
          for service in api-gateway auth-service user-service permission-service notification-service file-service file-processing-service webhook-service mobile-bff web-bff; do
            if [ -d "$service" ] && [ -f "$service/Dockerfile" ]; then
              echo "Deploying $service to production..."
              
              # Create/update production secrets
              kubectl create secret generic ${service}-secrets \
                --from-literal=database-url="$DATABASE_URL" \
                --from-literal=redis-url="$REDIS_URL" \
                --from-literal=jwt-secret="$JWT_SECRET" \
                --from-literal=api-key="$API_KEY" \
                --from-literal=airtable-api-key="$AIRTABLE_API_KEY" \
                --from-literal=airtable-base-id="$AIRTABLE_BASE_ID" \
                --from-literal=sentry-dsn="$SENTRY_DSN" \
                --dry-run=client -o yaml | kubectl apply -f -
              
              # Rolling update with zero downtime
              kubectl set image deployment/${service} ${service}=${{ env.REGISTRY }}/${{ github.repository_owner }}/${service}:${{ github.sha }} || echo "Deployment ${service} not found, skipping..."
              kubectl annotate deployment/${service} deployment.kubernetes.io/revision-
            fi
          done

      - name: Wait for production deployment
        run: |
          for service in api-gateway auth-service user-service permission-service notification-service file-service file-processing-service webhook-service mobile-bff web-bff; do
            if kubectl get deployment ${service} >/dev/null 2>&1; then
              kubectl rollout status deployment/${service} --timeout=600s || echo "Deployment ${service} rollout timeout"
            fi
          done

      - name: Production health checks
        run: |
          # Comprehensive health checks
          sleep 60
          
          # Health check with retries
          for i in {1..5}; do
            if curl -f -m 30 https://api.pyairtable.dev/health; then
              echo "Production health check passed"
              break
            elif [ $i -eq 5 ]; then
              echo "Production health check failed after 5 attempts"
              exit 1
            else
              echo "Health check attempt $i failed, retrying in 30s..."
              sleep 30
            fi
          done

      - name: Post-deployment verification
        run: |
          # Run production smoke tests
          echo "Running post-deployment verification..."
          # Add your verification scripts here

  # Rollback capability
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    environment:
      name: ${{ needs.deploy-production.result == 'failure' && 'production' || 'staging' }}
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure cluster access
        run: |
          if [[ "${{ needs.deploy-production.result }}" == "failure" ]]; then
            echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > ~/.kube/config
          else
            echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > ~/.kube/config
          fi
          chmod 600 ~/.kube/config

      - name: Rollback deployments
        run: |
          for service in api-gateway auth-service user-service permission-service notification-service file-service file-processing-service webhook-service mobile-bff web-bff; do
            if kubectl get deployment ${service} >/dev/null 2>&1; then
              echo "Rolling back $service..."
              kubectl rollout undo deployment/${service}
              kubectl rollout status deployment/${service} --timeout=300s
            fi
          done

      - name: Notify team of rollback
        if: always()
        run: |
          echo "Deployment failed, rollback completed"
          # Add notification logic here (Slack, email, etc.)

  # Security post-deployment
  security-scan-deployed:
    name: Security Scan Deployed Services
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: always() && needs.deploy-staging.result == 'success'
    steps:
      - name: Container security scan
        run: |
          # Scan deployed containers for vulnerabilities
          for service in api-gateway auth-service user-service permission-service notification-service file-service file-processing-service webhook-service mobile-bff web-bff; do
            echo "Scanning $service container..."
            # Add container scanning tools like Trivy, Snyk, etc.
          done

      - name: Runtime security monitoring
        run: |
          echo "Setting up runtime security monitoring..."
          # Configure runtime security monitoring